---
title: "Validation"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Validation}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
suppressPackageStartupMessages(library(ggplot2))
library(malariasimulation)
library(malariaEquilibrium)
library(reshape2)
```

# Equilibrium testing

This vignette demonstrates that the IBM is consistent with the independently written [equilibrium solution](https://github.com/mrc-ide/malariaEquilibrium). Using the principle of triangulation, we provide evidence for the validity of this model.  

## Parameterising the model

Let's start by parameterising the model with the default parameters from the equilibirium solution code.

This involves:

 * translating parameters to their new names, and
 * removing parameters that are not used in the new model
 
```{r}
year <- 365
sim_length <- 50 * year
human_population <- 100

remove_keys <- function(x, n) { for (name in n) { x[[name]] <- NULL }; x }

jamie_params <- load_parameter_set("Jamie_parameters.rds")

params <- remove_keys(
  jamie_params,
  c(
    'rT', # to be included in treatment validation
    'rP', # to be included in treatment validation
    'tl', # unused!
    'aA', # used for microscopy and pcr calculations
    'aU', # used for microscopy and pcr calculations
    'tau',# unused!
    'f', # used later to calculate blood_meal_rates
    'Q0', # used later to calculate blood_meal_rates
    'cd_w', # unused!
    'cd_p', # unused!
    'cT' # to be included in treatment validation
  )
)

simparams <- translate_jamie(params)
simparams[['human_population']] <- human_population

#parameterise single species
simparams$variety_proportions <- 1
simparams$blood_meal_rates <- jamie_params$f * jamie_params$Q0
```

Next we want to estimate the yearly EIR. This is an input parameter for the equilibrium solution, but for the IBM it's an emergent statistic...

```{r}

estimate_eir <- function() {
  output <- run_simulation(sim_length, simparams)
  sum(tail(output$mean_EIR, year))
}
```

We run our IBM model initialised with these state proportions to check for a divergence:

Let's first set up some utility functions:

```{r}

get_state_proportions <- function(EIR) {
  eq <- human_equilibrium(EIR = EIR, ft = 0, p = jamie_params, age = 0:100)
  colSums(eq$states[,c('S', 'D', 'A', 'U')])
}

get_FOIM <- function(EIR) {
  human_equilibrium(EIR = EIR, ft = 0, p = jamie_params, age = 0:100)$FOIM
}

run_simulation_from_equilibrium <- function(state_props) {
  simparams$s_proportion <- state_props[['S']]
  simparams$d_proportion <- state_props[['D']]
  simparams$a_proportion <- state_props[['A']]
  simparams$u_proportion <- state_props[['U']]
  run_simulation(sim_length, simparams)
}

plot_counts_against_equilibrium <- function(output, state_props) {
  equilibrium <- data.frame(
    timestep = seq(sim_length),
    human_S_count = rep(state_props[['S']] * simparams$human_population, sim_length),
    human_D_count = rep(state_props[['D']] * simparams$human_population, sim_length),
    human_A_count = rep(state_props[['A']] * simparams$human_population, sim_length),
    human_U_count = rep(state_props[['U']] * simparams$human_population, sim_length)
  )
  ggplot(
    melt(output[c(
      'timestep',
      'human_S_count',
      'human_D_count',
      'human_A_count',
      'human_U_count'
    )],
    'timestep'
    ),
  ) + geom_line(
    aes(x = timestep, y = value, group = variable, color = variable)
  ) + geom_line(
    data = melt(equilibrium, 'timestep'),
    aes(x = timestep, y = value, group = variable, color = variable),
    linetype = 'dashed'
  )
}
```

And then run our models.

# Vector ODE model

```{r}
#use the ode vector model
simparams$vector_ode <- TRUE
simparams$density <- 100
simparams$human_population <- 1000
EIR <- estimate_eir()
state_props <- get_state_proportions(EIR)
print(system.time({output <- run_simulation_from_equilibrium(state_props)}))
plot_counts_against_equilibrium(output, state_props)
```


Let's have a look at the mosquitos

```{r}
ggplot(
  output[c(
      'timestep',
      'FOIM_1'
    )]
) + geom_line(
  aes(x = timestep, y = FOIM_1)
) + geom_line(
    data = data.frame(timestep=seq(sim_length), FOIM=rep(get_FOIM(EIR), sim_length)),
    aes(x = timestep, y = FOIM),
    linetype = 'dashed'
)
```


Plot EIR vs Prev

```{r}
#use the ode vector model
simparams$vector_ode <- TRUE
simparams$human_population <- 1000
eirs <- c()
prevs <- c()
for (density in c(10, 100, 500, 1000, 5000, 10000)) {
  simparams$density <- density
  EIR <- estimate_eir()
  state_props <- get_state_proportions(EIR)
  output <- run_simulation_from_equilibrium(state_props)
  prevs <- c(prevs, mean(tail(output$human_D_count)) / simparams$human_population)
  eirs <- c(eirs, mean(tail(output$mean_EIR)))
}

ggplot(data.frame(eir = eirs, prev = prevs)) + geom_point(aes(x = eir, y = prev))
```


```{r}
ggplot(
  output[c(
      'timestep',
      'mean_EIR'
    )]
) + geom_line(
  aes(x = timestep, y = mean_EIR)
)
```

Immunity

```{r}
ggplot(
  melt(
    output[c(
      'timestep',
      'human_ICA_mean',
      'human_ICM_mean',
      'human_IB_mean',
      'human_ID_mean'
    )],
    'timestep'
  )
) + geom_line(
  aes(x = timestep, y = value, group = variable, color = variable)
)
```

...the distribution of M

```{r}
ggplot(
  melt(
    output[c(
      'timestep',
      'mosquito_Im_counts',
      'mosquito_Sm_counts',
      'mosquito_Pm_counts'
    )],
    'timestep'
  )
) + geom_line(
  aes(x = timestep, y = value, group = variable, color = variable)
)
```

# Vector IBM model

```{r}
simparams$vector_ode <- FALSE
EIR <- estimate_eir()
state_props <- get_state_proportions(EIR)
print(system.time({output <- run_simulation_from_equilibrium(state_props)}))
plot_counts_against_equilibrium(output, state_props)
```


