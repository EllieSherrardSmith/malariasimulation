---
title: "Validation"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Validation}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(malariasimulation)
library(malariaEquilibrium)
library(ggplot2)
library(reshape2)
```

# Equilibrium testing

This vignette demonstrates that the IBM is consistent with the independently written [equilibrium solution](https://github.com/mrc-ide/malariaEquilibrium). Using the principle of triangulation, we provide evidence for the validity of this model.  

## Parameterising the model

Let's start by parameterising the model with the default parameters from the equilibirium solution code.

This involves:

 * translating parameters to their new names, and
 * removing parameters that are not used in the new model
 
```{r}
year <- 365
sim_length <- 50 * year
human_population <- 100

remove_keys <- function(x, n) { for (name in n) { x[[name]] <- NULL }; x }

jamie_params <- load_parameter_set("Jamie_parameters.rds")

params <- remove_keys(
  jamie_params,
  c(
    's2',
    'rT', # makes sense
    'rP', # makes sense
    'tl',
    'g_inf',
    'fd0',
    'aA',
    'aU',
    'b1',
    'PM',
    'tau',
    'f',
    'Q0',
    'cd_w',
    'cd_p',
    'cT',
    'dE' # not sure if this translation works
  )
)

simparams <- translate_jamie(params)
simparams[['human_population']] <- human_population

#parameterise single species
simparams$variety_proportions <- 1
simparams$blood_meal_rates <- jamie_params$f * jamie_params$Q0
```

Next we want to estimate the yearly EIR. This is an input parameter for the equilibrium solution, but for the IBM it's an emergent statistic...

```{r}

estimate_eir <- function() {
  output <- run_simulation(5 * year, simparams)
  sum(output$mean_EIR[output$timestep > (4 * year)])
}

EIR <- estimate_eir()

print(paste("Estimated final year EIR to be", EIR, sep=" "))
```

We run our IBM model initialised with these state proportions to check for a divergence:

```{r}

get_state_proportions <- function(EIR) {
  eq <- human_equilibrium(EIR = EIR, ft = 0, p = jamie_params, age = 0:100)
  colSums(eq$states[,c('S', 'D', 'A', 'U')])
}

run_simulation_from_equilibrium <- function(state_props) {
  simparams$s_proportion <- state_props[['S']]
  simparams$d_proportion <- state_props[['D']]
  simparams$a_proportion <- state_props[['A']]
  simparams$u_proportion <- state_props[['U']]
  run_simulation(sim_length, simparams)
}

plot_counts_against_equilibrium <- function(output, state_props) {
  equilibrium <- data.frame(
    timestep = seq(sim_length),
    human_S_count = rep(state_props[['S']] * human_population, sim_length),
    human_D_count = rep(state_props[['D']] * human_population, sim_length),
    human_A_count = rep(state_props[['A']] * human_population, sim_length),
    human_U_count = rep(state_props[['U']] * human_population, sim_length)
  )
  ggplot(
    melt(output[c(
      'timestep',
      'human_S_count',
      'human_D_count',
      'human_A_count',
      'human_U_count'
    )],
    'timestep'
    ),
  ) + geom_line(
    aes(x = timestep, y = value, group = variable, color = variable)
  ) + geom_line(
    data = melt(equilibrium, 'timestep'),
    aes(x = timestep, y = value, group = variable, color = variable),
    linetype = 'dashed'
  )
}

state_props <- get_state_proportions(EIR)
print(system.time({output <- run_simulation_from_equilibrium(state_props)}))
plot_counts_against_equilibrium(output, state_props)
```

# Vector ODE model

We can do the same validation with the vector ODE model:

```{r}

#use the ode vector model
simparams$vector_ode <- TRUE
simparams$density <- 10

EIR <- estimate_eir()
print(paste("Estimated final year EIR to be", EIR, sep=" "))

state_props <- get_state_proportions(EIR)
print(system.time({output <- run_simulation_from_equilibrium(state_props)}))
plot_counts_against_equilibrium(output, state_props)
```


Let's have a look at the mosquitos
```{r}
ggplot(
  melt(
    output[c(
      'timestep',
      names(output)[grepl('mosquito', names(output))]
    )],
    'timestep'
  )
) + geom_line(
  aes(x = timestep, y = value, group = variable, color = variable)
)
```